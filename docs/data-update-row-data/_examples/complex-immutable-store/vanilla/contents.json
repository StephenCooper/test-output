{"isEnterprise":true,"isLocale":false,"isIntegratedCharts":false,"entryFileName":"main.js","mainFileName":"main.js","scriptFiles":["main.js"],"styleFiles":["styles.css"],"files":{"styles.css":".example-wrapper {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n#myGrid {\n    flex: 1 1 0px;\n    width: 100%;\n}\n\n.number {\n    text-align: right;\n}\n","main.js":"const MIN_BOOK_COUNT = 10;\nconst MAX_BOOK_COUNT = 20;\n\nconst MIN_TRADE_COUNT = 1;\nconst MAX_TRADE_COUNT = 10;\n\nconst products = [\n  \"Palm Oil\",\n  \"Rubber\",\n  \"Wool\",\n  \"Amber\",\n  \"Copper\",\n  \"Lead\",\n  \"Zinc\",\n  \"Tin\",\n  \"Aluminium\",\n  \"Aluminium Alloy\",\n  \"Nickel\",\n  \"Cobalt\",\n  \"Molybdenum\",\n  \"Recycled Steel\",\n  \"Corn\",\n  \"Oats\",\n  \"Rough Rice\",\n  \"Soybeans\",\n  \"Rapeseed\",\n  \"Soybean Meal\",\n  \"Soybean Oil\",\n  \"Wheat\",\n  \"Milk\",\n  \"Coca\",\n  \"Coffee C\",\n  \"Cotton No.2\",\n  \"Sugar No.11\",\n  \"Sugar No.14\",\n];\n\nconst portfolios = [\n  \"Aggressive\",\n  \"Defensive\",\n  \"Income\",\n  \"Speculative\",\n  \"Hybrid\",\n];\n\n// as we create books, we remember what products they belong to, so we can\n// add to these books later when use clicks one of the buttons\nconst productToPortfolioToBooks = {};\n\n// start the book id's and trade id's at some future random number,\n// looks more realistic than starting them at 0\nlet nextBookId = 62472;\nlet nextTradeId = 24287;\nlet nextBatchId = 101;\n\nconst columnDefs = [\n  // these are the row groups, so they are all hidden (they are showd in the group column)\n  {\n    field: \"product\",\n    enableRowGroup: true,\n    rowGroupIndex: 0,\n    hide: true,\n  },\n  {\n    field: \"portfolio\",\n    enableRowGroup: true,\n    rowGroupIndex: 1,\n    hide: true,\n  },\n  {\n    field: \"book\",\n    enableRowGroup: true,\n    rowGroupIndex: 2,\n    hide: true,\n  },\n\n  // all the other columns (visible and not grouped)\n  {\n    field: \"batch\",\n    width: 100,\n    cellClass: \"number\",\n    aggFunc: \"max\",\n    enableValue: true,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    field: \"current\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    field: \"previous\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"Change\",\n    valueGetter: changeValueGetter,\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"PL 1\",\n    field: \"pl1\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"PL 2\",\n    field: \"pl2\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"Gain-DX\",\n    field: \"gainDx\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"SX / PX\",\n    field: \"sxPx\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"99 Out\",\n    field: \"_99Out\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"Submitter ID\",\n    field: \"submitterID\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n  {\n    headerName: \"Submitted Deal ID\",\n    field: \"submitterDealID\",\n    width: 200,\n    aggFunc: \"sum\",\n    enableValue: true,\n    cellClass: \"number\",\n    valueFormatter: numberCellFormatter,\n    cellRenderer: \"agAnimateShowChangeCellRenderer\",\n  },\n\n  // some string values, that do not get aggregated\n  {\n    field: \"dealType\",\n    enableRowGroup: true,\n    filter: \"agTextColumnFilter\",\n  },\n  {\n    headerName: \"Bid\",\n    field: \"bidFlag\",\n    enableRowGroup: true,\n    width: 100,\n    filter: \"agTextColumnFilter\",\n  },\n  { field: \"comment\", editable: true, filter: \"agTextColumnFilter\" },\n];\n\n// simple value getter, however we can see how many times it gets called. this\n// gives us an indication to how many rows get recalculated when data changes\nfunction changeValueGetter(params) {\n  return params.data.previous - params.data.current;\n}\n\n// a list of the data, that we modify as we go. if you are using an immutable\n// data store (such as Redux) then this would be similar to your store of data.\nlet globalRowData = [];\n\n// build up the test data\nfunction createRowData() {\n  globalRowData = [];\n  const thisBatch = nextBatchId++;\n  for (let i = 0; i < products.length; i++) {\n    const product = products[i];\n    productToPortfolioToBooks[product] = {};\n    for (let j = 0; j < portfolios.length; j++) {\n      const portfolio = portfolios[j];\n      productToPortfolioToBooks[product][portfolio] = [];\n\n      const bookCount = randomBetween(MAX_BOOK_COUNT, MIN_BOOK_COUNT);\n\n      for (let k = 0; k < bookCount; k++) {\n        const book = createBookName();\n        productToPortfolioToBooks[product][portfolio].push(book);\n        const tradeCount = randomBetween(MAX_TRADE_COUNT, MIN_TRADE_COUNT);\n        for (let l = 0; l < tradeCount; l++) {\n          const trade = createTradeRecord(product, portfolio, book, thisBatch);\n          globalRowData.push(trade);\n        }\n      }\n    }\n  }\n}\n\nfunction randomBetween(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction createTradeRecord(product, portfolio, book, batch) {\n  const current = Math.floor(Math.random() * 100000) + 100;\n  const previous = current + Math.floor(Math.random() * 10000) - 2000;\n  const trade = {\n    product: product,\n    portfolio: portfolio,\n    book: book,\n    trade: createTradeId(),\n    submitterID: randomBetween(10, 1000),\n    submitterDealID: randomBetween(10, 1000),\n    dealType: Math.random() < 0.2 ? \"Physical\" : \"Financial\",\n    bidFlag: Math.random() < 0.5 ? \"Buy\" : \"Sell\",\n    current: current,\n    previous: previous,\n    pl1: randomBetween(100, 1000),\n    pl2: randomBetween(100, 1000),\n    gainDx: randomBetween(100, 1000),\n    sxPx: randomBetween(100, 1000),\n    _99Out: randomBetween(100, 1000),\n    batch: batch,\n  };\n  return trade;\n}\n\nfunction numberCellFormatter(params) {\n  return Math.floor(params.value)\n    .toString()\n    .replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\");\n}\n\nfunction createBookName() {\n  nextBookId++;\n  return \"GL-\" + nextBookId;\n}\n\nfunction createTradeId() {\n  nextTradeId++;\n  return nextTradeId;\n}\n\nlet gridApi;\n\nconst gridOptions = {\n  columnDefs: columnDefs,\n  defaultColDef: {\n    width: 120,\n    filter: \"agNumberColumnFilter\",\n  },\n  autoGroupColumnDef: {\n    width: 250,\n    field: \"trade\",\n  },\n  rowSelection: {\n    mode: \"multiRow\",\n    groupSelects: \"descendants\",\n    headerCheckbox: false,\n  },\n  rowData: globalRowData,\n  suppressAggFuncInHeader: true,\n  getRowId: (params) => String(params.data.trade),\n  onGridReady: (params) => {\n    createRowData();\n    params.api.setGridOption(\"rowData\", globalRowData);\n  },\n};\n\nfunction updateData() {\n  removeSomeItems();\n  addSomeItems();\n  updateSomeItems();\n  gridApi.setGridOption(\"rowData\", globalRowData);\n}\n\nfunction updateSomeItems() {\n  const updateCount = randomBetween(1, 6);\n  const itemsToUpdate = [];\n  for (let k = 0; k < updateCount; k++) {\n    if (globalRowData.length === 0) {\n      continue;\n    }\n    const indexToUpdate = Math.floor(Math.random() * globalRowData.length);\n    const itemToUpdate = globalRowData[indexToUpdate];\n\n    // make a copy of the item, and make some changes, so we are behaving\n    // similar to how the\n    const updatedItem = updateImmutableObject(itemToUpdate, {\n      previous: itemToUpdate.current,\n      current: itemToUpdate.current + randomBetween(0, 1000) - 500,\n    });\n    globalRowData[indexToUpdate] = updatedItem;\n\n    itemsToUpdate.push(updatedItem);\n  }\n  return itemsToUpdate;\n}\n\nfunction addSomeItems() {\n  const addCount = randomBetween(1, 6);\n  const itemsToAdd = [];\n  const batch = nextBatchId++;\n  for (let j = 0; j < addCount; j++) {\n    const portfolio = portfolios[Math.floor(Math.random() * portfolios.length)];\n    const books = productToPortfolioToBooks[\"Palm Oil\"][portfolio];\n    const book = books[Math.floor(Math.random() * books.length)];\n    const product = products[Math.floor(Math.random() * products.length)];\n    const trade = createTradeRecord(product, portfolio, book, batch);\n    itemsToAdd.push(trade);\n    globalRowData.push(trade);\n  }\n  return itemsToAdd;\n}\n\nfunction removeSomeItems() {\n  const removeCount = randomBetween(1, 6);\n  const itemsToRemove = [];\n  for (let i = 0; i < removeCount; i++) {\n    if (globalRowData.length === 0) {\n      continue;\n    }\n    const indexToRemove = randomBetween(0, globalRowData.length);\n    const itemToRemove = globalRowData[indexToRemove];\n    globalRowData.splice(indexToRemove, 1);\n    itemsToRemove.push(itemToRemove);\n  }\n  return itemsToRemove;\n}\n\n// makes a copy of the original and merges in the new values\nfunction updateImmutableObject(original, newValues) {\n  // start with new object\n  const newObject = {};\n\n  // copy in the old values\n  Object.keys(original).forEach((key) => {\n    newObject[key] = original[key];\n  });\n\n  // now override with the new values\n  Object.keys(newValues).forEach((key) => {\n    newObject[key] = newValues[key];\n  });\n\n  return newObject;\n}\n\n// after page is loaded, create the grid.\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  const eGridDiv = document.querySelector(\"#myGrid\");\n  gridApi = agGrid.createGrid(eGridDiv, gridOptions);\n});\n","index.html":"<div class=\"example-wrapper\">\n    <div style=\"margin-bottom: 5px\">\n        <button onclick=\"updateData()\">Update</button>\n    </div>\n    <div id=\"myGrid\"></div>\n</div>\n"},"boilerPlateFiles":{},"packageJson":{"name":"ag-grid-example","dependencies":{"ag-grid-community":"33.1.0","ag-grid-enterprise":"33.1.0"}}}