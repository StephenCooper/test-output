{"isEnterprise":true,"isLocale":false,"isIntegratedCharts":false,"entryFileName":"main.js","mainFileName":"main.js","scriptFiles":["data.js","fakeServer.js","main.js"],"styleFiles":["styles.css"],"files":{"styles.css":".example-wrapper {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n#myGrid {\n    flex: 1 1 0px;\n    width: 100%;\n}\n","data.js":"const MIN_BOOK_COUNT = 1;\nconst MAX_BOOK_COUNT = 5;\nconst MIN_TRADE_COUNT = 1;\nconst MAX_TRADE_COUNT = 5;\n\nconst products = [\n    'Palm Oil',\n    'Rubber',\n    'Wool',\n    'Amber',\n    'Copper',\n    'Lead',\n    'Zinc',\n    'Tin',\n    'Aluminium',\n    'Aluminium Alloy',\n    'Nickel',\n    'Cobalt',\n    'Molybdenum',\n    'Recycled Steel',\n    'Corn',\n    'Oats',\n    'Rough Rice',\n    'Soybeans',\n    'Rapeseed',\n    'Soybean Meal',\n    'Soybean Oil',\n    'Wheat',\n    'Milk',\n    'Coca',\n    'Coffee C',\n    'Cotton No.2',\n    'Sugar No.11',\n    'Sugar No.14',\n];\n\nconst portfolios = ['Aggressive', 'Defensive', 'Income', 'Speculative', 'Hybrid'];\n\nlet nextTradeId = 0;\nlet nextBookId = 62472;\n\nvar data = [];\n\n// IIFE to create initial data\n(function () {\n    const lastUpdated = new Date();\n\n    for (let i = 0; i < products.length; i++) {\n        const product = products[i];\n        for (let j = 0; j < portfolios.length; j++) {\n            const portfolio = portfolios[j];\n\n            const bookCount = randomBetween(MAX_BOOK_COUNT, MIN_BOOK_COUNT);\n\n            for (let k = 0; k < bookCount; k++) {\n                const book = createBookName();\n                const tradeCount = randomBetween(MAX_TRADE_COUNT, MIN_TRADE_COUNT);\n                for (let l = 0; l < tradeCount; l++) {\n                    const trade = createTradeRecord(product, portfolio, book);\n\n                    trade.updateCount = 0;\n                    trade.lastUpdated = lastUpdated;\n\n                    data.push(trade);\n                }\n            }\n        }\n    }\n})();\n\nvar dataObservers = [];\n\nfunction randomUpdates({ numRemove, numAdd, numUpdate }) {\n    // removes\n    const remove = [];\n    for (let i = 0; i < Math.ceil(numRemove); i++) {\n        const idx = randomBetween(0, data.length - 1);\n        const d = data[idx];\n        data.splice(idx, 1);\n        remove.push(d);\n    }\n\n    // updates\n    const update = [];\n    for (let i = 0; i < numUpdate; i++) {\n        const idx = randomBetween(0, data.length - 1);\n        const d = data[idx];\n        d.previous = d.current;\n        d.current = d.previous + 13;\n        d.lastUpdated = new Date();\n        d.updateCount = ++d.updateCount;\n        update.push(d);\n    }\n\n    // adds\n    const add = [];\n    const lastUpdate = new Date();\n    for (let i = 0; i < Math.ceil(numAdd); i++) {\n        const product = products[randomBetween(0, products.length - 1)];\n        const portfolio = portfolios[randomBetween(0, portfolios.length - 1)];\n        const book = createBookName();\n        const newRecord = createTradeRecord(product, portfolio, book);\n        newRecord.lastUpdated = lastUpdate;\n        newRecord.updateCount = 0;\n        add.push(newRecord);\n    }\n    data.push(...add);\n\n    // notify observers\n    dataObservers.forEach((obs) => obs({ update, add, remove }));\n}\n\nfunction randomBetween(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction createTradeRecord(product, portfolio, book) {\n    const current = Math.floor(Math.random() * 100000) + 100;\n    const previous = current + Math.floor(Math.random() * 10000) - 2000;\n    const trade = {\n        product: product,\n        portfolio: portfolio,\n        book: book,\n        tradeId: createTradeId(),\n        submitterID: randomBetween(10, 1000),\n        submitterDealID: randomBetween(10, 1000),\n        dealType: Math.random() < 0.2 ? 'Physical' : 'Financial',\n        bidFlag: Math.random() < 0.5 ? 'Buy' : 'Sell',\n        current: current,\n        previous: previous,\n        pl1: randomBetween(100, 1000),\n        pl2: randomBetween(100, 1000),\n        gainDx: randomBetween(100, 1000),\n        sxPx: randomBetween(100, 1000),\n        _99Out: randomBetween(100, 1000),\n    };\n    return trade;\n}\n\nfunction createBookName() {\n    return 'GL-' + nextBookId++;\n}\n\nfunction createTradeId() {\n    return nextTradeId++;\n}\n","fakeServer.js":"function FakeServer(data) {\n    alasql.options.cache = false;\n\n    return {\n        getData: function (request) {\n            const results = executeQuery(request);\n            const resultSize = executeQuery({ ...request, endRow: undefined }, true).length;\n\n            return {\n                success: true,\n                rows: results,\n                lastRow: resultSize,\n            };\n        },\n    };\n\n    function executeQuery(request, suppressLogging) {\n        const groupByResult = executeRowGroupQuery(request, suppressLogging);\n\n        return groupByResult;\n    }\n\n    function executeRowGroupQuery(request, suppressLogging) {\n        const groupByQuery = buildGroupBySql(request);\n\n        if (!suppressLogging) {\n            console.log('[FakeServer] - about to execute row group query:', groupByQuery);\n        }\n\n        return alasql(groupByQuery, [data]);\n    }\n\n    function buildGroupBySql(request) {\n        return (\n            selectSql(request) +\n            ' FROM ?' +\n            whereSql(request) +\n            groupBySql(request) +\n            orderBySql(request) +\n            limitSql(request)\n        );\n    }\n\n    function selectSql(request) {\n        const rowGroupCols = request.rowGroupCols;\n        const valueCols = request.valueCols;\n        const groupKeys = request.groupKeys;\n\n        if (isDoingGrouping(rowGroupCols, groupKeys)) {\n            const rowGroupCol = rowGroupCols[groupKeys.length];\n            const colsToSelect = [rowGroupCol.id];\n\n            valueCols.forEach(function (valueCol) {\n                colsToSelect.push(valueCol.aggFunc + '(' + valueCol.id + ') AS ' + valueCol.id);\n            });\n\n            return 'SELECT ' + colsToSelect.join(', ');\n        }\n\n        return 'SELECT *';\n    }\n\n    function whereSql(request) {\n        const rowGroups = request.rowGroupCols;\n        const groupKeys = request.groupKeys;\n        const whereParts = [];\n\n        if (groupKeys) {\n            groupKeys.forEach(function (key, i) {\n                const value = typeof key === 'string' ? \"'\" + key + \"'\" : key;\n\n                whereParts.push(rowGroups[i].id + ' = ' + value);\n            });\n        }\n\n        if (whereParts.length > 0) {\n            return ' WHERE ' + whereParts.join(' AND ');\n        }\n\n        return '';\n    }\n\n    function groupBySql(request) {\n        const rowGroupCols = request.rowGroupCols;\n        const groupKeys = request.groupKeys;\n\n        if (isDoingGrouping(rowGroupCols, groupKeys)) {\n            const rowGroupCol = rowGroupCols[groupKeys.length];\n\n            return ' GROUP BY ' + rowGroupCol.id + ' HAVING count(*) > 0';\n        }\n\n        return '';\n    }\n\n    function orderBySql(request) {\n        const sortModel = request.sortModel;\n\n        if (sortModel.length === 0) return '';\n\n        const sorts = sortModel.map(function (s) {\n            return s.colId + ' ' + s.sort.toUpperCase();\n        });\n\n        return ' ORDER BY ' + sorts.join(', ');\n    }\n\n    function limitSql(request) {\n        if (request.endRow == undefined || request.startRow == undefined) {\n            return '';\n        }\n        const blockSize = request.endRow - request.startRow;\n\n        return ' LIMIT ' + blockSize + ' OFFSET ' + request.startRow;\n    }\n\n    function isDoingGrouping(rowGroupCols, groupKeys) {\n        // we are not doing grouping if at the lowest level\n        return rowGroupCols.length > groupKeys.length;\n    }\n\n    function getLastRowIndex(request, results) {\n        if (!results || results.length === 0) {\n            return null;\n        }\n        if (request.endRow == undefined || request.startRow == undefined) {\n            return results.length;\n        }\n        const currentLastRow = request.startRow + results.length;\n\n        return currentLastRow <= request.endRow ? currentLastRow : -1;\n    }\n}\n\n// IE Workaround - as templates literals are not supported\nfunction interpolate(str, o) {\n    return str.replace(/{([^{}]*)}/g, function (a, b) {\n        const r = o[b];\n        return typeof r === 'string' || typeof r === 'number' ? r : a;\n    });\n}\n","main.js":"const columnDefs = [\n  { field: \"tradeId\" },\n  { field: \"portfolio\" },\n  { field: \"book\" },\n  { field: \"previous\" },\n  { field: \"current\" },\n  {\n    field: \"lastUpdated\",\n    wrapHeaderText: true,\n    autoHeaderHeight: true,\n    valueFormatter: (params) => {\n      const ts = params.data.lastUpdated;\n      if (ts) {\n        const hh_mm_ss = ts.toLocaleString().split(\" \")[1];\n        const SSS = ts.getMilliseconds();\n        return `${hh_mm_ss}:${SSS}`;\n      }\n      return \"\";\n    },\n  },\n  { field: \"updateCount\" },\n];\n\nlet gridApi;\n\nconst gridOptions = {\n  columnDefs,\n  defaultColDef: {\n    flex: 1,\n    minWidth: 100,\n    enableCellChangeFlash: true,\n  },\n  autoGroupColumnDef: {\n    minWidth: 220,\n  },\n  getRowId: (params) => {\n    let rowId = \"\";\n    if (params.parentKeys && params.parentKeys.length) {\n      rowId += params.parentKeys.join(\"-\") + \"-\";\n    }\n    if (params.data.tradeId != null) {\n      rowId += params.data.tradeId;\n    }\n    return rowId;\n  },\n  onGridReady: (params) => {\n    disable(\"#stopUpdates\", true);\n\n    // setup the fake server\n    const server = FakeServer(data);\n\n    // create datasource with a reference to the fake server\n    const datasource = getServerSideDatasource(server);\n\n    // register the datasource with the grid\n    params.api.setGridOption(\"serverSideDatasource\", datasource);\n\n    // register interest in data changes\n    dataObservers.push((t) => {\n      params.api.applyServerSideTransactionAsync(t);\n    });\n  },\n  asyncTransactionWaitMillis: 1000,\n  rowModelType: \"serverSide\",\n};\n\nfunction getServerSideDatasource(server) {\n  return {\n    getRows: (params) => {\n      const response = server.getData(params.request);\n\n      // adding delay to simulate real server call\n      setTimeout(() => {\n        if (response.success) {\n          // call the success callback\n          params.success({\n            rowData: response.rows,\n            rowCount: response.lastRow,\n          });\n        } else {\n          // inform the grid request failed\n          params.fail();\n        }\n      }, 300);\n    },\n  };\n}\n\nlet interval;\n\nfunction startUpdates() {\n  interval = setInterval(\n    () => randomUpdates({ numUpdate: 10, numAdd: 1, numRemove: 1 }),\n    10,\n  );\n  disable(\"#stopUpdates\", false);\n  disable(\"#startUpdates\", true);\n}\n\nfunction stopUpdates() {\n  if (interval !== undefined) {\n    clearInterval(interval);\n  }\n  disable(\"#stopUpdates\", true);\n  disable(\"#startUpdates\", false);\n}\n\nfunction disable(id, disabled) {\n  document.querySelector(id).disabled = disabled;\n}\n\n// setup the grid after the page has finished loading\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  const gridDiv = document.querySelector(\"#myGrid\");\n  gridApi = agGrid.createGrid(gridDiv, gridOptions);\n});\n","index.html":"<div class=\"example-wrapper\">\n    <div style=\"margin-bottom: 5px\">\n        <button id=\"startUpdates\" onclick=\"startUpdates()\">Start Updates</button>\n        <button id=\"stopUpdates\" onclick=\"stopUpdates()\">Stop Updates</button>\n    </div>\n    <div id=\"myGrid\"></div>\n</div>\n"},"boilerPlateFiles":{},"packageJson":{"name":"ag-grid-example","dependencies":{"ag-grid-community":"33.1.0","ag-grid-enterprise":"33.1.0"}},"extras":["alasql"]}