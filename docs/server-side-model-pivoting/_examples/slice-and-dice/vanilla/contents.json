{"isEnterprise":true,"isLocale":false,"isIntegratedCharts":false,"entryFileName":"main.js","mainFileName":"main.js","scriptFiles":["countries.js","customAgeFilter.js","server.js","main.js"],"styleFiles":[],"files":{"countries.js":"function getCountries() {\n    return [\n        'United States',\n        'Russia',\n        'Australia',\n        'Canada',\n        'Norway',\n        'China',\n        'Zimbabwe',\n        'Netherlands',\n        'South Korea',\n        'Croatia',\n        'France',\n        'Japan',\n        'Hungary',\n        'Germany',\n        'Poland',\n        'South Africa',\n        'Sweden',\n        'Ukraine',\n        'Italy',\n        'Czech Republic',\n        'Austria',\n        'Finland',\n        'Romania',\n        'Great Britain',\n        'Jamaica',\n        'Singapore',\n        'Belarus',\n        'Chile',\n        'Spain',\n        'Tunisia',\n        'Brazil',\n        'Slovakia',\n        'Costa Rica',\n        'Bulgaria',\n        'Switzerland',\n        'New Zealand',\n        'Estonia',\n        'Kenya',\n        'Ethiopia',\n        'Trinidad and Tobago',\n        'Turkey',\n        'Morocco',\n        'Bahamas',\n        'Slovenia',\n        'Armenia',\n        'Azerbaijan',\n        'India',\n        'Puerto Rico',\n        'Egypt',\n        'Kazakhstan',\n        'Iran',\n        'Georgia',\n        'Lithuania',\n        'Cuba',\n        'Colombia',\n        'Mongolia',\n        'Uzbekistan',\n        'North Korea',\n        'Tajikistan',\n        'Kyrgyzstan',\n        'Greece',\n        'Macedonia',\n        'Moldova',\n        'Chinese Taipei',\n        'Indonesia',\n        'Thailand',\n        'Vietnam',\n        'Latvia',\n        'Venezuela',\n        'Mexico',\n        'Nigeria',\n        'Qatar',\n        'Serbia',\n        'Serbia and Montenegro',\n        'Hong Kong',\n        'Denmark',\n        'Portugal',\n        'Argentina',\n        'Afghanistan',\n        'Gabon',\n        'Dominican Republic',\n        'Belgium',\n        'Kuwait',\n        'United Arab Emirates',\n        'Cyprus',\n        'Israel',\n        'Algeria',\n        'Montenegro',\n        'Iceland',\n        'Paraguay',\n        'Cameroon',\n        'Saudi Arabia',\n        'Ireland',\n        'Malaysia',\n        'Uruguay',\n        'Togo',\n        'Mauritius',\n        'Syria',\n        'Botswana',\n        'Guatemala',\n        'Bahrain',\n        'Grenada',\n        'Uganda',\n        'Sudan',\n        'Ecuador',\n        'Panama',\n        'Eritrea',\n        'Sri Lanka',\n        'Mozambique',\n        'Barbados',\n    ];\n}\n","customAgeFilter.js":"\nclass CustomAgeFilter  {\n    eGui;\n    filterValue = null;\n    params;\n\n    init(params) {\n        this.eGui = document.createElement('div');\n        this.eGui.innerHTML = `<div>  \n            <label>    \n                <input type=\"radio\" name=\"ageFilterValue\" data-ref=\"btAll\" checked/> All  \n            </label>  \n            <label>    \n                <input type=\"radio\" name=\"ageFilterValue\" data-ref=\"bt20\"/> 20  \n            </label>  \n            <label>    \n                <input type=\"radio\" name=\"ageFilterValue\" data-ref=\"bt22\"/> 22  \n            </label>\n          </div>`;\n\n        this.filterValue = null;\n        this.params = params;\n\n        // var that = this;\n\n        this.eGui.querySelector('[data-ref=\"btAll\"]').addEventListener('change', this.onSelection.bind(this, null));\n        this.eGui.querySelector('[data-ref=\"bt20\"]').addEventListener('change', this.onSelection.bind(this, 20));\n        this.eGui.querySelector('[data-ref=\"bt22\"]').addEventListener('change', this.onSelection.bind(this, 22));\n    }\n\n    onSelection(value) {\n        this.filterValue = value;\n        this.params.filterChangedCallback();\n    }\n\n    getGui() {\n        return this.eGui;\n    }\n\n    isFilterActive() {\n        return this.filterValue !== null;\n    }\n\n    doesFilterPass(params) {\n        // not needed for server side filtering\n        const { node } = params;\n        const value = this.params.getValue(node);\n        return value == this.filterValue;\n    }\n\n    getModel() {\n        if (this.filterValue === null) {\n            return null;\n        } else {\n            // the format of what you return depends on your server side, just\n            // return something that your server side can work with.\n            return {\n                filter: this.filterValue,\n                type: 'equals',\n            };\n        }\n    }\n\n    setModel(model) {\n        if (model && model.filter === 20) {\n            this.eGui.querySelector('[data-ref=\"bt20\"]').checked = true;\n            this.filterValue = 20;\n        } else if (model && model.filter === 22) {\n            this.eGui.querySelector('[data-ref=\"bt22\"]').checked = true;\n            this.filterValue = 22;\n        } else {\n            this.eGui.querySelector('[data-ref=\"btAll\"]').checked = true;\n            this.filterValue = null;\n        }\n    }\n}\n","server.js":"function createServerSideDatasource(fakeServer) {\n    class ServerSideDatasource {\n        constructor(fakeServer) {\n            this.fakeServer = fakeServer;\n        }\n\n        getRows(params) {\n            this.fakeServer.getData(params.request, (resultForGrid, lastRow, pivotFields) => {\n                params.success({\n                    rowData: resultForGrid,\n                    rowCount: lastRow,\n                    pivotResultFields: pivotFields,\n                });\n            });\n        }\n    }\n\n    return new ServerSideDatasource(fakeServer);\n}\n\nfunction createFakeServer(data) {\n    // THIS IS NOT PRODUCTION CODE\n    // in your application, you should be implementing the server logic in your server, maybe in JavaScript, but\n    // also maybe in Java, C# or another server side language. The server side would then typically query a database\n    // or another data store to get the data, and the grouping, aggregation and pivoting would be done by the data store.\n    // This fake server is only intended to demonstrate the interface between AG Grid and the server side. The\n    // implementation details are not intended to be an example of how your server side should create results.\n\n    return new FakeServer(data);\n}\n\nclass FakeServer {\n    constructor(allData) {\n        this.allData = allData;\n    }\n\n    getData(request, callback) {\n        let {\n            // Filtering\n            filterModel,\n\n            // Pivoting\n            pivotCols,\n            pivotMode,\n\n            // Grouping\n            groupKeys,\n            rowGroupCols,\n\n            // Aggregation\n            valueCols,\n\n            // Sorting\n            sortModel,\n        } = request;\n\n        // Pivot is only active if we have pivot columns and aggregate columns\n        const pivotActive = pivotMode && pivotCols.length > 0 && valueCols.length > 0;\n\n        /** Filter data */\n        let rowData = this.filterList(this.allData, filterModel);\n\n        /** Pivot data */\n        let pivotFields = null;\n        if (pivotActive) {\n            const pivotResult = this.pivot(pivotCols, rowGroupCols, valueCols, rowData);\n            // Pivoted row data\n            rowData = pivotResult.data;\n            // Aggregate instead by the pivot columns\n            valueCols = pivotResult.aggCols;\n            // Pivoted columns fields to allow grid to generate pivot result columns\n            pivotFields = pivotResult.pivotFields;\n        }\n\n        /** Group & Aggregate data */\n        if (rowGroupCols.length > 0) {\n            // When grouping we only return data for one group per request, so filter the other data out\n            rowData = this.filterOutOtherGroups(rowData, groupKeys, rowGroupCols);\n\n            // If this group isn't the bottom level, then group the rows rather than returning them\n            const showingGroupLevel = rowGroupCols.length > groupKeys.length;\n            if (showingGroupLevel) {\n                rowData = this.buildGroupsFromData(rowData, rowGroupCols, groupKeys, valueCols);\n            }\n        } else if (pivotMode) {\n            // When pivoting without groups, aggregate all data into one row\n            const rootGroup = this.aggregateList(rowData, valueCols);\n            rowData = [rootGroup];\n        }\n\n        /** Sort data */\n        rowData = this.sortList(rowData, sortModel);\n\n        const lastRow = rowData.length;\n\n        /** Paginate data */\n        if (request.startRow != null && request.endRow != null) {\n            rowData = rowData.slice(request.startRow, request.endRow);\n        }\n\n        // so that the example behaves like a server side call, we put\n        // it in a timeout to a) give a delay and b) make it asynchronous\n        setTimeout(function () {\n            callback(rowData, lastRow, pivotFields);\n        }, 1000);\n    }\n\n    sortList(data, sortModel) {\n        const sortPresent = sortModel && sortModel.length > 0;\n        if (!sortPresent) {\n            return data;\n        }\n        // do an in memory sort of the data, across all the fields\n        const resultOfSort = data.slice();\n        resultOfSort.sort(function (a, b) {\n            for (let k = 0; k < sortModel.length; k++) {\n                const sortColModel = sortModel[k];\n                const valueA = a[sortColModel.colId];\n                const valueB = b[sortColModel.colId];\n                // this filter didn't find a difference, move onto the next one\n                if (valueA == valueB) {\n                    continue;\n                }\n                const sortDirection = sortColModel.sort === 'asc' ? 1 : -1;\n                if (valueA > valueB) {\n                    return sortDirection;\n                } else {\n                    return sortDirection * -1;\n                }\n            }\n            // no filters found a difference\n            return 0;\n        });\n        return resultOfSort;\n    }\n\n    filterList(data, filterModel) {\n        const filterPresent = filterModel && Object.keys(filterModel).length > 0;\n        if (!filterPresent) {\n            return data;\n        }\n\n        const resultOfFilter = [];\n        for (let i = 0; i < data.length; i++) {\n            const item = data[i];\n\n            if (filterModel.age) {\n                const age = item.age;\n                const allowedAge = parseInt(filterModel.age.filter);\n                if (filterModel.age.type == 'equals') {\n                    if (age !== allowedAge) {\n                        continue;\n                    }\n                } else if (filterModel.age.type == 'lessThan') {\n                    if (age >= allowedAge) {\n                        continue;\n                    }\n                } else {\n                    if (age <= allowedAge) {\n                        continue;\n                    }\n                }\n            }\n\n            if (filterModel.year) {\n                if (filterModel.year.values.indexOf(item.year.toString()) < 0) {\n                    // year didn't match, so skip this record\n                    continue;\n                }\n            }\n\n            if (filterModel.country) {\n                if (filterModel.country.values.indexOf(item.country) < 0) {\n                    continue;\n                }\n            }\n\n            resultOfFilter.push(item);\n        }\n\n        return resultOfFilter;\n    }\n\n    // function does pivoting. this is very funky logic, doing pivoting and creating pivot result columns on the fly.\n    // if you are using the AG Grid Enterprise Row Model, remember this would all be done on your server side with a\n    // database or something that does pivoting for you - this messy code is just for demo purposes on how to use\n    // ag-Gird, it's not supposed to be beautiful production quality code.\n    pivot(pivotCols, rowGroupCols, valueCols, data) {\n        const pivotData = [];\n        const aggColsList = [];\n        const pivotFields = new Set();\n        data.forEach(function (item) {\n            const pivotValues = [];\n            pivotCols.forEach(function (pivotCol) {\n                const pivotField = pivotCol.id;\n                const pivotValue = item[pivotField];\n                if (pivotValue !== null && pivotValue !== undefined && pivotValue.toString) {\n                    pivotValues.push(pivotValue.toString());\n                } else {\n                    pivotValues.push('-');\n                }\n            });\n            const pivotItem = {};\n\n            valueCols.forEach(function (valueCol) {\n                const valField = valueCol.id;\n\n                const pivotKey = pivotValues.join('_');\n                const colKey = `${pivotKey}_${valField}`;\n                if (!pivotFields.has(colKey)) {\n                    pivotFields.add(colKey);\n                    // add value col so server can aggregate later\n                    aggColsList.push({\n                        id: colKey,\n                        field: colKey,\n                        aggFunc: valueCol.aggFunc,\n                    });\n                }\n\n                const value = item[valField];\n                pivotItem[colKey] = value;\n            });\n\n            rowGroupCols.forEach(function (rowGroupCol) {\n                const rowGroupField = rowGroupCol.id;\n                pivotItem[rowGroupField] = item[rowGroupField];\n            });\n\n            pivotData.push(pivotItem);\n        });\n\n        return {\n            data: pivotData,\n            aggCols: aggColsList,\n            pivotFields: [...pivotFields],\n        };\n    }\n\n    buildGroupsFromData(rowData, rowGroupCols, groupKeys, valueCols) {\n        const rowGroupCol = rowGroupCols[groupKeys.length];\n        const field = rowGroupCol.id;\n        const mappedRowData = this.groupBy(rowData, field);\n\n        if (!mappedRowData) {\n            return [];\n        }\n\n        const groups = [];\n        const that = this;\n        for (const key in mappedRowData) {\n            const thisRowData = mappedRowData[key];\n            const groupItem = that.aggregateList(thisRowData, valueCols);\n            groupItem[field] = key;\n            groups.push(groupItem);\n        }\n        return groups;\n    }\n\n    aggregateList(rowData, valueCols) {\n        const result = {};\n\n        for (let i = 0; i < valueCols.length; i++) {\n            const col = valueCols[i];\n            const field = col.id;\n\n            // the aggregation we do depends on which agg func the user picked\n            switch (col.aggFunc) {\n                case 'sum':\n                    let sum = 0;\n                    for (let i = 0; i < rowData.length; i++) {\n                        const row = rowData[i];\n                        const value = row[field];\n                        if (value === undefined) continue;\n\n                        sum += value;\n                    }\n                    result[field] = sum;\n                    break;\n                case 'min':\n                    let min = null;\n                    for (let i = 0; i < rowData.length; i++) {\n                        const row = rowData[i];\n                        const value = row[field];\n                        if (value === undefined) continue;\n\n                        if (min === null || min > value) {\n                            min = value;\n                        }\n                    }\n                    result[field] = min;\n                    break;\n                case 'max':\n                    let max = null;\n                    for (let i = 0; i < rowData.length; i++) {\n                        const row = rowData[i];\n                        const value = row[field];\n                        if (value === undefined) continue;\n\n                        if (max === null || max < value) {\n                            max = value;\n                        }\n                    }\n                    result[field] = max;\n                    break;\n                case 'random':\n                    result[field] = Math.random(); // just make up a number\n                    break;\n                default:\n                    console.warn('unrecognised aggregation function: ' + valueCol.aggFunc);\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    // if user is down some group levels, we take everything else out. eg\n    // if user has opened the two groups United States and 2002, we filter\n    // out everything that is not equal to United States and 2002.\n    filterOutOtherGroups(originalData, groupKeys, rowGroupCols) {\n        let filteredData = originalData;\n        const that = this;\n\n        // if we are inside a group, then filter out everything that is not\n        // part of this group\n        groupKeys.forEach(function (groupKey, index) {\n            const rowGroupCol = rowGroupCols[index];\n            const field = rowGroupCol.id;\n\n            filteredData = that.filter(filteredData, function (item) {\n                return item[field] == groupKey;\n            });\n        });\n\n        return filteredData;\n    }\n\n    groupBy(data, field) {\n        const result = {};\n        data.forEach(function (item) {\n            const key = item[field];\n            let listForThisKey = result[key];\n            if (!listForThisKey) {\n                listForThisKey = [];\n                result[key] = listForThisKey;\n            }\n            listForThisKey.push(item);\n        });\n        return result;\n    }\n\n    filter(data, callback) {\n        const result = [];\n        data.forEach(function (item) {\n            if (callback(item)) {\n                result.push(item);\n            }\n        });\n        return result;\n    }\n}\n","main.js":"const countries = getCountries();\n\nconst columnDefs = [\n  { field: \"athlete\", enableRowGroup: true, filter: false },\n  {\n    field: \"age\",\n    enableRowGroup: true,\n    enablePivot: true,\n    filter: CustomAgeFilter,\n  },\n  {\n    field: \"country\",\n    enableRowGroup: true,\n    enablePivot: true,\n    rowGroup: true,\n    hide: true,\n    filter: \"agSetColumnFilter\",\n    filterParams: { values: countries },\n  },\n  {\n    field: \"year\",\n    enableRowGroup: true,\n    enablePivot: true,\n    rowGroup: true,\n    hide: true,\n    filter: \"agSetColumnFilter\",\n    filterParams: {\n      values: [\"2000\", \"2002\", \"2004\", \"2006\", \"2008\", \"2010\", \"2012\"],\n    },\n  },\n  { field: \"sport\", enableRowGroup: true, enablePivot: true, filter: false },\n  { field: \"gold\", aggFunc: \"sum\", filter: false, enableValue: true },\n  { field: \"silver\", aggFunc: \"sum\", filter: false, enableValue: true },\n  { field: \"bronze\", aggFunc: \"sum\", filter: false, enableValue: true },\n];\n\nlet gridApi;\n\nconst gridOptions = {\n  defaultColDef: {\n    flex: 1,\n    minWidth: 150,\n    // restrict what aggregation functions the columns can have,\n    // include a custom function 'random' that just returns a\n    // random number\n    allowedAggFuncs: [\"sum\", \"min\", \"max\", \"random\"],\n    filter: true,\n  },\n  autoGroupColumnDef: {\n    width: 180,\n  },\n  columnDefs: columnDefs,\n  rowModelType: \"serverSide\",\n  rowGroupPanelShow: \"always\",\n  pivotPanelShow: \"always\",\n  sideBar: true,\n  maxConcurrentDatasourceRequests: 1,\n  maxBlocksInCache: 2,\n  purgeClosedRowNodes: true,\n};\n\n// setup the grid after the page has finished loading\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  const gridDiv = document.querySelector(\"#myGrid\");\n  gridApi = agGrid.createGrid(gridDiv, gridOptions);\n\n  fetch(\"https://www.ag-grid.com/example-assets/olympic-winners.json\")\n    .then((response) => response.json())\n    .then(function (data) {\n      const fakeServer = createFakeServer(data);\n      const datasource = createServerSideDatasource(fakeServer);\n      gridApi.setGridOption(\"serverSideDatasource\", datasource);\n    });\n});\n","index.html":"<div id=\"myGrid\" style=\"height: 100%\"></div>\n","interfaces.ts":"\nexport interface IOlympicData {\n    athlete: string,\n    age: number,\n    country: string,\n    year: number,\n    date: string,\n    sport: string,\n    gold: number,\n    silver: number,\n    bronze: number,\n    total: number\n}"},"boilerPlateFiles":{},"packageJson":{"name":"ag-grid-example","dependencies":{"ag-grid-community":"33.1.0","ag-grid-enterprise":"33.1.0"}}}