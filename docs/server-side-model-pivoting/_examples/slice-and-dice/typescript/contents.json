{"isEnterprise":true,"isLocale":false,"isIntegratedCharts":false,"entryFileName":"main.ts","mainFileName":"main.ts","styleFiles":[],"files":{"countries.ts":"export function getCountries() {\n    return [\n        'United States',\n        'Russia',\n        'Australia',\n        'Canada',\n        'Norway',\n        'China',\n        'Zimbabwe',\n        'Netherlands',\n        'South Korea',\n        'Croatia',\n        'France',\n        'Japan',\n        'Hungary',\n        'Germany',\n        'Poland',\n        'South Africa',\n        'Sweden',\n        'Ukraine',\n        'Italy',\n        'Czech Republic',\n        'Austria',\n        'Finland',\n        'Romania',\n        'Great Britain',\n        'Jamaica',\n        'Singapore',\n        'Belarus',\n        'Chile',\n        'Spain',\n        'Tunisia',\n        'Brazil',\n        'Slovakia',\n        'Costa Rica',\n        'Bulgaria',\n        'Switzerland',\n        'New Zealand',\n        'Estonia',\n        'Kenya',\n        'Ethiopia',\n        'Trinidad and Tobago',\n        'Turkey',\n        'Morocco',\n        'Bahamas',\n        'Slovenia',\n        'Armenia',\n        'Azerbaijan',\n        'India',\n        'Puerto Rico',\n        'Egypt',\n        'Kazakhstan',\n        'Iran',\n        'Georgia',\n        'Lithuania',\n        'Cuba',\n        'Colombia',\n        'Mongolia',\n        'Uzbekistan',\n        'North Korea',\n        'Tajikistan',\n        'Kyrgyzstan',\n        'Greece',\n        'Macedonia',\n        'Moldova',\n        'Chinese Taipei',\n        'Indonesia',\n        'Thailand',\n        'Vietnam',\n        'Latvia',\n        'Venezuela',\n        'Mexico',\n        'Nigeria',\n        'Qatar',\n        'Serbia',\n        'Serbia and Montenegro',\n        'Hong Kong',\n        'Denmark',\n        'Portugal',\n        'Argentina',\n        'Afghanistan',\n        'Gabon',\n        'Dominican Republic',\n        'Belgium',\n        'Kuwait',\n        'United Arab Emirates',\n        'Cyprus',\n        'Israel',\n        'Algeria',\n        'Montenegro',\n        'Iceland',\n        'Paraguay',\n        'Cameroon',\n        'Saudi Arabia',\n        'Ireland',\n        'Malaysia',\n        'Uruguay',\n        'Togo',\n        'Mauritius',\n        'Syria',\n        'Botswana',\n        'Guatemala',\n        'Bahrain',\n        'Grenada',\n        'Uganda',\n        'Sudan',\n        'Ecuador',\n        'Panama',\n        'Eritrea',\n        'Sri Lanka',\n        'Mozambique',\n        'Barbados',\n    ];\n}\n","customAgeFilter.ts":"import type { IDoesFilterPassParams, IFilterComp, IFilterParams } from 'ag-grid-community';\n\nexport class CustomAgeFilter implements IFilterComp {\n    eGui!: HTMLElement;\n    filterValue: number | null = null;\n    params: IFilterParams;\n\n    init(params: IFilterParams) {\n        this.eGui = document.createElement('div');\n        this.eGui.innerHTML = `<div>  \n            <label>    \n                <input type=\"radio\" name=\"ageFilterValue\" data-ref=\"btAll\" checked/> All  \n            </label>  \n            <label>    \n                <input type=\"radio\" name=\"ageFilterValue\" data-ref=\"bt20\"/> 20  \n            </label>  \n            <label>    \n                <input type=\"radio\" name=\"ageFilterValue\" data-ref=\"bt22\"/> 22  \n            </label>\n          </div>`;\n\n        this.filterValue = null;\n        this.params = params;\n\n        // var that = this;\n\n        this.eGui.querySelector('[data-ref=\"btAll\"]')!.addEventListener('change', this.onSelection.bind(this, null));\n        this.eGui.querySelector('[data-ref=\"bt20\"]')!.addEventListener('change', this.onSelection.bind(this, 20));\n        this.eGui.querySelector('[data-ref=\"bt22\"]')!.addEventListener('change', this.onSelection.bind(this, 22));\n    }\n\n    onSelection(value: number | null) {\n        this.filterValue = value;\n        this.params.filterChangedCallback();\n    }\n\n    getGui() {\n        return this.eGui;\n    }\n\n    isFilterActive() {\n        return this.filterValue !== null;\n    }\n\n    doesFilterPass(params: IDoesFilterPassParams) {\n        // not needed for server side filtering\n        const { node } = params;\n        const value = this.params.getValue(node);\n        return value == this.filterValue;\n    }\n\n    getModel() {\n        if (this.filterValue === null) {\n            return null;\n        } else {\n            // the format of what you return depends on your server side, just\n            // return something that your server side can work with.\n            return {\n                filter: this.filterValue,\n                type: 'equals',\n            };\n        }\n    }\n\n    setModel(model: any) {\n        if (model && model.filter === 20) {\n            this.eGui.querySelector<HTMLInputElement>('[data-ref=\"bt20\"]')!.checked = true;\n            this.filterValue = 20;\n        } else if (model && model.filter === 22) {\n            this.eGui.querySelector<HTMLInputElement>('[data-ref=\"bt22\"]')!.checked = true;\n            this.filterValue = 22;\n        } else {\n            this.eGui.querySelector<HTMLInputElement>('[data-ref=\"btAll\"]')!.checked = true;\n            this.filterValue = null;\n        }\n    }\n}\n","server.ts":"export function createServerSideDatasource(fakeServer) {\n    class ServerSideDatasource {\n        constructor(fakeServer) {\n            this.fakeServer = fakeServer;\n        }\n\n        getRows(params) {\n            this.fakeServer.getData(params.request, (resultForGrid, lastRow, pivotFields) => {\n                params.success({\n                    rowData: resultForGrid,\n                    rowCount: lastRow,\n                    pivotResultFields: pivotFields,\n                });\n            });\n        }\n    }\n\n    return new ServerSideDatasource(fakeServer);\n}\n\nexport function createFakeServer(data) {\n    // THIS IS NOT PRODUCTION CODE\n    // in your application, you should be implementing the server logic in your server, maybe in JavaScript, but\n    // also maybe in Java, C# or another server side language. The server side would then typically query a database\n    // or another data store to get the data, and the grouping, aggregation and pivoting would be done by the data store.\n    // This fake server is only intended to demonstrate the interface between AG Grid and the server side. The\n    // implementation details are not intended to be an example of how your server side should create results.\n\n    return new FakeServer(data);\n}\n\nclass FakeServer {\n    constructor(allData) {\n        this.allData = allData;\n    }\n\n    getData(request, callback) {\n        let {\n            // Filtering\n            filterModel,\n\n            // Pivoting\n            pivotCols,\n            pivotMode,\n\n            // Grouping\n            groupKeys,\n            rowGroupCols,\n\n            // Aggregation\n            valueCols,\n\n            // Sorting\n            sortModel,\n        } = request;\n\n        // Pivot is only active if we have pivot columns and aggregate columns\n        const pivotActive = pivotMode && pivotCols.length > 0 && valueCols.length > 0;\n\n        /** Filter data */\n        let rowData = this.filterList(this.allData, filterModel);\n\n        /** Pivot data */\n        let pivotFields = null;\n        if (pivotActive) {\n            const pivotResult = this.pivot(pivotCols, rowGroupCols, valueCols, rowData);\n            // Pivoted row data\n            rowData = pivotResult.data;\n            // Aggregate instead by the pivot columns\n            valueCols = pivotResult.aggCols;\n            // Pivoted columns fields to allow grid to generate pivot result columns\n            pivotFields = pivotResult.pivotFields;\n        }\n\n        /** Group & Aggregate data */\n        if (rowGroupCols.length > 0) {\n            // When grouping we only return data for one group per request, so filter the other data out\n            rowData = this.filterOutOtherGroups(rowData, groupKeys, rowGroupCols);\n\n            // If this group isn't the bottom level, then group the rows rather than returning them\n            const showingGroupLevel = rowGroupCols.length > groupKeys.length;\n            if (showingGroupLevel) {\n                rowData = this.buildGroupsFromData(rowData, rowGroupCols, groupKeys, valueCols);\n            }\n        } else if (pivotMode) {\n            // When pivoting without groups, aggregate all data into one row\n            const rootGroup = this.aggregateList(rowData, valueCols);\n            rowData = [rootGroup];\n        }\n\n        /** Sort data */\n        rowData = this.sortList(rowData, sortModel);\n\n        const lastRow = rowData.length;\n\n        /** Paginate data */\n        if (request.startRow != null && request.endRow != null) {\n            rowData = rowData.slice(request.startRow, request.endRow);\n        }\n\n        // so that the example behaves like a server side call, we put\n        // it in a timeout to a) give a delay and b) make it asynchronous\n        setTimeout(function () {\n            callback(rowData, lastRow, pivotFields);\n        }, 1000);\n    }\n\n    sortList(data, sortModel) {\n        const sortPresent = sortModel && sortModel.length > 0;\n        if (!sortPresent) {\n            return data;\n        }\n        // do an in memory sort of the data, across all the fields\n        const resultOfSort = data.slice();\n        resultOfSort.sort(function (a, b) {\n            for (let k = 0; k < sortModel.length; k++) {\n                const sortColModel = sortModel[k];\n                const valueA = a[sortColModel.colId];\n                const valueB = b[sortColModel.colId];\n                // this filter didn't find a difference, move onto the next one\n                if (valueA == valueB) {\n                    continue;\n                }\n                const sortDirection = sortColModel.sort === 'asc' ? 1 : -1;\n                if (valueA > valueB) {\n                    return sortDirection;\n                } else {\n                    return sortDirection * -1;\n                }\n            }\n            // no filters found a difference\n            return 0;\n        });\n        return resultOfSort;\n    }\n\n    filterList(data, filterModel) {\n        const filterPresent = filterModel && Object.keys(filterModel).length > 0;\n        if (!filterPresent) {\n            return data;\n        }\n\n        const resultOfFilter = [];\n        for (let i = 0; i < data.length; i++) {\n            const item = data[i];\n\n            if (filterModel.age) {\n                const age = item.age;\n                const allowedAge = parseInt(filterModel.age.filter);\n                if (filterModel.age.type == 'equals') {\n                    if (age !== allowedAge) {\n                        continue;\n                    }\n                } else if (filterModel.age.type == 'lessThan') {\n                    if (age >= allowedAge) {\n                        continue;\n                    }\n                } else {\n                    if (age <= allowedAge) {\n                        continue;\n                    }\n                }\n            }\n\n            if (filterModel.year) {\n                if (filterModel.year.values.indexOf(item.year.toString()) < 0) {\n                    // year didn't match, so skip this record\n                    continue;\n                }\n            }\n\n            if (filterModel.country) {\n                if (filterModel.country.values.indexOf(item.country) < 0) {\n                    continue;\n                }\n            }\n\n            resultOfFilter.push(item);\n        }\n\n        return resultOfFilter;\n    }\n\n    // function does pivoting. this is very funky logic, doing pivoting and creating pivot result columns on the fly.\n    // if you are using the AG Grid Enterprise Row Model, remember this would all be done on your server side with a\n    // database or something that does pivoting for you - this messy code is just for demo purposes on how to use\n    // ag-Gird, it's not supposed to be beautiful production quality code.\n    pivot(pivotCols, rowGroupCols, valueCols, data) {\n        const pivotData = [];\n        const aggColsList = [];\n        const pivotFields = new Set();\n        data.forEach(function (item) {\n            const pivotValues = [];\n            pivotCols.forEach(function (pivotCol) {\n                const pivotField = pivotCol.id;\n                const pivotValue = item[pivotField];\n                if (pivotValue !== null && pivotValue !== undefined && pivotValue.toString) {\n                    pivotValues.push(pivotValue.toString());\n                } else {\n                    pivotValues.push('-');\n                }\n            });\n            const pivotItem = {};\n\n            valueCols.forEach(function (valueCol) {\n                const valField = valueCol.id;\n\n                const pivotKey = pivotValues.join('_');\n                const colKey = `${pivotKey}_${valField}`;\n                if (!pivotFields.has(colKey)) {\n                    pivotFields.add(colKey);\n                    // add value col so server can aggregate later\n                    aggColsList.push({\n                        id: colKey,\n                        field: colKey,\n                        aggFunc: valueCol.aggFunc,\n                    });\n                }\n\n                const value = item[valField];\n                pivotItem[colKey] = value;\n            });\n\n            rowGroupCols.forEach(function (rowGroupCol) {\n                const rowGroupField = rowGroupCol.id;\n                pivotItem[rowGroupField] = item[rowGroupField];\n            });\n\n            pivotData.push(pivotItem);\n        });\n\n        return {\n            data: pivotData,\n            aggCols: aggColsList,\n            pivotFields: [...pivotFields],\n        };\n    }\n\n    buildGroupsFromData(rowData, rowGroupCols, groupKeys, valueCols) {\n        const rowGroupCol = rowGroupCols[groupKeys.length];\n        const field = rowGroupCol.id;\n        const mappedRowData = this.groupBy(rowData, field);\n\n        if (!mappedRowData) {\n            return [];\n        }\n\n        const groups = [];\n        const that = this;\n        for (const key in mappedRowData) {\n            const thisRowData = mappedRowData[key];\n            const groupItem = that.aggregateList(thisRowData, valueCols);\n            groupItem[field] = key;\n            groups.push(groupItem);\n        }\n        return groups;\n    }\n\n    aggregateList(rowData, valueCols) {\n        const result = {};\n\n        for (let i = 0; i < valueCols.length; i++) {\n            const col = valueCols[i];\n            const field = col.id;\n\n            // the aggregation we do depends on which agg func the user picked\n            switch (col.aggFunc) {\n                case 'sum':\n                    let sum = 0;\n                    for (let i = 0; i < rowData.length; i++) {\n                        const row = rowData[i];\n                        const value = row[field];\n                        if (value === undefined) continue;\n\n                        sum += value;\n                    }\n                    result[field] = sum;\n                    break;\n                case 'min':\n                    let min = null;\n                    for (let i = 0; i < rowData.length; i++) {\n                        const row = rowData[i];\n                        const value = row[field];\n                        if (value === undefined) continue;\n\n                        if (min === null || min > value) {\n                            min = value;\n                        }\n                    }\n                    result[field] = min;\n                    break;\n                case 'max':\n                    let max = null;\n                    for (let i = 0; i < rowData.length; i++) {\n                        const row = rowData[i];\n                        const value = row[field];\n                        if (value === undefined) continue;\n\n                        if (max === null || max < value) {\n                            max = value;\n                        }\n                    }\n                    result[field] = max;\n                    break;\n                case 'random':\n                    result[field] = Math.random(); // just make up a number\n                    break;\n                default:\n                    console.warn('unrecognised aggregation function: ' + valueCol.aggFunc);\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    // if user is down some group levels, we take everything else out. eg\n    // if user has opened the two groups United States and 2002, we filter\n    // out everything that is not equal to United States and 2002.\n    filterOutOtherGroups(originalData, groupKeys, rowGroupCols) {\n        let filteredData = originalData;\n        const that = this;\n\n        // if we are inside a group, then filter out everything that is not\n        // part of this group\n        groupKeys.forEach(function (groupKey, index) {\n            const rowGroupCol = rowGroupCols[index];\n            const field = rowGroupCol.id;\n\n            filteredData = that.filter(filteredData, function (item) {\n                return item[field] == groupKey;\n            });\n        });\n\n        return filteredData;\n    }\n\n    groupBy(data, field) {\n        const result = {};\n        data.forEach(function (item) {\n            const key = item[field];\n            let listForThisKey = result[key];\n            if (!listForThisKey) {\n                listForThisKey = [];\n                result[key] = listForThisKey;\n            }\n            listForThisKey.push(item);\n        });\n        return result;\n    }\n\n    filter(data, callback) {\n        const result = [];\n        data.forEach(function (item) {\n            if (callback(item)) {\n                result.push(item);\n            }\n        });\n        return result;\n    }\n}\n","main.ts":"import {\n  ColDef,\n  ColGroupDef,\n  CustomFilterModule,\n  GridApi,\n  GridOptions,\n  IServerSideDatasource,\n  ModuleRegistry,\n  NumberFilterModule,\n  RowModelType,\n  SideBarDef,\n  ValidationModule,\n  createGrid,\n} from \"ag-grid-community\";\nimport {\n  ColumnMenuModule,\n  ColumnsToolPanelModule,\n  ContextMenuModule,\n  FiltersToolPanelModule,\n  RowGroupingModule,\n  RowGroupingPanelModule,\n  ServerSideRowModelModule,\n  SetFilterModule,\n} from \"ag-grid-enterprise\";\nimport { getCountries } from \"./countries\";\nimport { CustomAgeFilter } from \"./customAgeFilter\";\nimport { createFakeServer, createServerSideDatasource } from \"./server\";\nimport { IOlympicData } from \"./interfaces\";\n\nModuleRegistry.registerModules([\n  NumberFilterModule,\n  ColumnsToolPanelModule,\n  FiltersToolPanelModule,\n  ColumnMenuModule,\n  ContextMenuModule,\n  CustomFilterModule,\n  RowGroupingModule,\n  ServerSideRowModelModule,\n  SetFilterModule,\n  RowGroupingPanelModule,\n  ValidationModule /* Development Only */,\n]);\n\nconst countries = getCountries();\n\nconst columnDefs: ColDef[] = [\n  { field: \"athlete\", enableRowGroup: true, filter: false },\n  {\n    field: \"age\",\n    enableRowGroup: true,\n    enablePivot: true,\n    filter: CustomAgeFilter,\n  },\n  {\n    field: \"country\",\n    enableRowGroup: true,\n    enablePivot: true,\n    rowGroup: true,\n    hide: true,\n    filter: \"agSetColumnFilter\",\n    filterParams: { values: countries },\n  },\n  {\n    field: \"year\",\n    enableRowGroup: true,\n    enablePivot: true,\n    rowGroup: true,\n    hide: true,\n    filter: \"agSetColumnFilter\",\n    filterParams: {\n      values: [\"2000\", \"2002\", \"2004\", \"2006\", \"2008\", \"2010\", \"2012\"],\n    },\n  },\n  { field: \"sport\", enableRowGroup: true, enablePivot: true, filter: false },\n  { field: \"gold\", aggFunc: \"sum\", filter: false, enableValue: true },\n  { field: \"silver\", aggFunc: \"sum\", filter: false, enableValue: true },\n  { field: \"bronze\", aggFunc: \"sum\", filter: false, enableValue: true },\n];\n\nlet gridApi: GridApi<IOlympicData>;\n\nconst gridOptions: GridOptions<IOlympicData> = {\n  defaultColDef: {\n    flex: 1,\n    minWidth: 150,\n    // restrict what aggregation functions the columns can have,\n    // include a custom function 'random' that just returns a\n    // random number\n    allowedAggFuncs: [\"sum\", \"min\", \"max\", \"random\"],\n    filter: true,\n  },\n  autoGroupColumnDef: {\n    width: 180,\n  },\n  columnDefs: columnDefs,\n  rowModelType: \"serverSide\",\n  rowGroupPanelShow: \"always\",\n  pivotPanelShow: \"always\",\n  sideBar: true,\n  maxConcurrentDatasourceRequests: 1,\n  maxBlocksInCache: 2,\n  purgeClosedRowNodes: true,\n};\n\n// setup the grid after the page has finished loading\nconst gridDiv = document.querySelector<HTMLElement>(\"#myGrid\")!;\ngridApi = createGrid(gridDiv, gridOptions);\n\nfetch(\"https://www.ag-grid.com/example-assets/olympic-winners.json\")\n  .then((response) => response.json())\n  .then(function (data) {\n    const fakeServer = createFakeServer(data);\n    const datasource = createServerSideDatasource(fakeServer);\n    gridApi!.setGridOption(\"serverSideDatasource\", datasource);\n  });\n","index.html":"<div id=\"myGrid\" style=\"height: 100%\"></div>\n","interfaces.ts":"\nexport interface IOlympicData {\n    athlete: string,\n    age: number,\n    country: string,\n    year: number,\n    date: string,\n    sport: string,\n    gold: number,\n    silver: number,\n    bronze: number,\n    total: number\n}"},"boilerPlateFiles":{"css.js":"if (typeof window !== 'undefined') {\n    var waitSeconds = 100;\n\n    var head = document.getElementsByTagName('head')[0];\n\n    var isWebkit = !!window.navigator.userAgent.match(/AppleWebKit\\/([^ ;]*)/);\n    var webkitLoadCheck = function (link, callback) {\n        setTimeout(function () {\n            for (var i = 0; i < document.styleSheets.length; i++) {\n                var sheet = document.styleSheets[i];\n                if (sheet.href == link.href) return callback();\n            }\n            webkitLoadCheck(link, callback);\n        }, 10);\n    };\n\n    var cssIsReloadable = function cssIsReloadable(links) {\n        // Css loaded on the page initially should be skipped by the first\n        // systemjs load, and marked for reload\n        var reloadable = true;\n        forEach(links, function (link) {\n            if (!link.hasAttribute('data-systemjs-css')) {\n                reloadable = false;\n                link.setAttribute('data-systemjs-css', '');\n            }\n        });\n        return reloadable;\n    };\n\n    var findExistingCSS = function findExistingCSS(url) {\n        // Search for existing link to reload\n        var links = head.getElementsByTagName('link');\n        return filter(links, function (link) {\n            return link.href === url;\n        });\n    };\n\n    var noop = function () {};\n\n    var loadCSS = function (url, existingLinks) {\n        const stylesUrl = url.includes('styles.css') || url.includes('style.css');\n        return new Promise((outerResolve, outerReject) => {\n            setTimeout(\n                () => {\n                    new Promise(function (resolve, reject) {\n                        var timeout = setTimeout(function () {\n                            reject('Unable to load CSS');\n                        }, waitSeconds * 1000);\n                        var _callback = function (error) {\n                            clearTimeout(timeout);\n                            link.onload = link.onerror = noop;\n                            setTimeout(function () {\n                                if (error) {\n                                    reject(error);\n                                    outerReject(error);\n                                } else {\n                                    resolve('');\n                                    outerResolve('');\n                                }\n                            }, 7);\n                        };\n                        var link = document.createElement('link');\n                        link.type = 'text/css';\n                        link.rel = 'stylesheet';\n                        link.href = url;\n                        link.setAttribute('data-systemjs-css', '');\n                        if (!isWebkit) {\n                            link.onload = function () {\n                                _callback();\n                            };\n                        } else {\n                            webkitLoadCheck(link, _callback);\n                        }\n                        link.onerror = function (event) {\n                            _callback(event.error || new Error('Error loading CSS file.'));\n                        };\n                        if (existingLinks.length) head.insertBefore(link, existingLinks[0]);\n                        else head.appendChild(link);\n                    })\n                        // Remove the old link regardless of loading outcome\n                        .then(\n                            function (result) {\n                                forEach(existingLinks, function (link) {\n                                    link.parentElement.removeChild(link);\n                                });\n                                return result;\n                            },\n                            function (err) {\n                                forEach(existingLinks, function (link) {\n                                    link.parentElement.removeChild(link);\n                                });\n                                throw err;\n                            }\n                        );\n                },\n                stylesUrl ? 5 : 0\n            );\n        });\n    };\n\n    exports.fetch = function (load) {\n        // dont reload styles loaded in the head\n        var links = findExistingCSS(load.address);\n        if (!cssIsReloadable(links)) return '';\n        return loadCSS(load.address, links);\n    };\n} else {\n    var builderPromise;\n    function getBuilder(loader) {\n        if (builderPromise) return builderPromise;\n\n        return (builderPromise = System['import']('./css-plugin-base.js', module.id).then(function (CSSPluginBase) {\n            return new CSSPluginBase(function compile(source, address) {\n                return {\n                    css: source,\n                    map: null,\n                    moduleSource: null,\n                    moduleFormat: null,\n                };\n            });\n        }));\n    }\n\n    exports.cssPlugin = true;\n    exports.fetch = function (load, fetch) {\n        if (!this.builder) return '';\n        return fetch(load);\n    };\n    exports.translate = function (load, opts) {\n        if (!this.builder) return '';\n        var loader = this;\n        return getBuilder(loader).then(function (builder) {\n            return builder.translate.call(loader, load, opts);\n        });\n    };\n    exports.instantiate = function (load, opts) {\n        if (!this.builder) return;\n        var loader = this;\n        return getBuilder(loader).then(function (builder) {\n            return builder.instantiate.call(loader, load, opts);\n        });\n    };\n    exports.bundle = function (loads, compileOpts, outputOpts) {\n        var loader = this;\n        return getBuilder(loader).then(function (builder) {\n            return builder.bundle.call(loader, loads, compileOpts, outputOpts);\n        });\n    };\n    exports.listAssets = function (loads, opts) {\n        var loader = this;\n        return getBuilder(loader).then(function (builder) {\n            return builder.listAssets.call(loader, loads, opts);\n        });\n    };\n}\n\n// Because IE8?\nfunction filter(arrayLike, func) {\n    var arr = [];\n    forEach(arrayLike, function (item) {\n        if (func(item)) arr.push(item);\n    });\n    return arr;\n}\n\n// Because IE8?\nfunction forEach(arrayLike, func) {\n    for (var i = 0; i < arrayLike.length; i++) {\n        func(arrayLike[i]);\n    }\n}\n","systemjs.config.js":"(function (global) {\n    System.config({\n        // DEMO ONLY! REAL CODE SHOULD NOT TRANSPILE IN THE BROWSER\n        transpiler: 'ts',\n        typescriptOptions: {},\n        meta: {\n            typescript: {\n                exports: 'ts',\n            },\n            '*.css': { loader: 'css' },\n        },\n        paths: {\n            // paths serve as alias\n            'npm:': 'https://cdn.jsdelivr.net/npm/',\n            ...systemJsPaths,\n        },\n        // map tells the System loader where to look for things\n        map: {\n            css: (boilerplatePath.length === 0 ? `./` : `${boilerplatePath}/`) + 'css.js',\n\n            ts: 'npm:plugin-typescript@8.0.0/lib/plugin.js',\n            tslib: 'npm:tslib@2.3.1/tslib.js',\n            typescript: 'npm:typescript@5.4.5/lib/typescript.min.js',\n\n            // appLocation comes from index.html\n            app: appLocation,\n            ...systemJsMap,\n        },\n        // packages tells the System loader how to load when no filename and/or no extension\n        packages: {\n            css: {},\n            app: {\n                main: './main.ts',\n                defaultExtension: 'ts',\n            },\n            'ag-grid-community': {\n                main: './dist/package/main.cjs.js',\n                defaultExtension: 'js',\n                format: 'cjs',\n            },\n            'ag-grid-enterprise': {\n                main: './dist/package/main.cjs.js',\n                defaultExtension: 'js',\n                format: 'cjs',\n            },\n            'ag-charts-types': {\n                defaultExtension: 'js',\n                format: 'cjs',\n            },\n            'ag-charts-community': {\n                defaultExtension: 'js',\n                format: 'cjs',\n            },\n            'ag-charts-enterprise': {\n                defaultExtension: 'js',\n                format: 'cjs',\n            },\n            '@ag-grid-community/locale': {\n                format: 'cjs',\n            },\n        },\n    });\n})(this);\n\nwindow.addEventListener('error', (e) => {\n    console.error('ERROR', e.message, e.filename);\n});\n"},"packageJson":{"name":"ag-grid-example","dependencies":{"ag-grid-community":"33.1.0","ag-grid-enterprise":"33.1.0"}}}